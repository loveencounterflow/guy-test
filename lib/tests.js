// Generated by CoffeeScript 1.8.0
(function() {
  var META, TRM, alert, badge, debug, echo, fetch_data_from_network, fetch_data_from_unreachable_network, help, info, log, read_file, rpr, settings, test, urge, warn, whisper;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'GUY-TEST/tests';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  echo = TRM.echo.bind(TRM);

  test = require('./main');

  read_file = function(route, handler) {
    return (require('fs')).readFile(route, {
      encoding: 'utf-8'
    }, function(error, text) {
      return handler(error, text);
    });
  };

  fetch_data_from_network = function(url, handler) {
    return setImmediate((function(_this) {
      return function() {
        return handler(null, 'the webpage you requested');
      };
    })(this));
  };

  fetch_data_from_unreachable_network = function(url, handler) {
    return setImmediate((function(_this) {
      return function() {
        return handler(new Error("network unreachable"));
      };
    })(this));
  };

  META = {};

  this["sync; checks fail"] = function(T) {
    var checks, name;
    name = T.name;
    checks = T.check(META[name]);
    T.eq(checks.length, 2);
    T.eq(checks[0]['message'], 'not equal: 42, 43');
    return T.eq(checks[1]['message'], 'not OK: false');
  };

  META["sync; checks fail"] = function(T) {
    T.eq(42, 43);
    return T.ok('another test' === 'another spring');
  };

  this["sync; fails because `xxx` is not recognized"] = function(T) {
    var checks, name;
    name = T.name;
    checks = T.check(META[name]);
    T.eq(checks.length, 1);
    return T.eq(checks[0]['message'], 'xxx is not defined');
  };

  META["sync; fails because `xxx` is not recognized"] = function(T) {
    return xxx;
  };

  this["sync; fails because argument to `T.ok` isn't `true`"] = function(T) {
    var checks, name;
    name = T.name;
    checks = T.check(META[name]);
    T.eq(checks.length, 1);
    return T.eq(checks[0]['message'], 'not OK: false');
  };

  META["sync; fails because argument to `T.ok` isn't `true`"] = function(T) {
    return T.ok(123 === 456);
  };

  this["sync; calling `T.fail`, but proceeding with a successful test"] = function(T) {
    var checks, name;
    name = T.name;
    checks = T.check(META[name]);
    T.eq(checks.length, 1);
    return T.eq(checks[0]['message'], 'this was not in my plan');
  };

  META["sync; calling `T.fail`, but proceeding with a successful test"] = function(T) {
    T.fail("this was not in my plan");
    return T.eq(108, 108);
  };

  this["sync; `done` can be used in synchronous tests"] = function(T, done) {
    var idx, n, _i;
    n = 0;
    for (idx = _i = 0; _i < 10000000; idx = ++_i) {
      n = (Math.sin(idx)) * (Math.cos(idx + 0.3));
    }
    T.eq(n, -0.41904553942341144);
    return done();
  };

  if (module.parent == null) {
    settings = {
      'timeout': 250
    };
    test(this, settings);
  }

}).call(this);
