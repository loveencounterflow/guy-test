// Generated by CoffeeScript 1.9.0
(function() {
  var ASYNC, CND, alert, badge, debug, echo, help, info, log, njs_domain, rpr, urge, warn, whisper,
    __slice = [].slice;

  njs_domain = require('domain');

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = 'TEST';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  ASYNC = require('async');

  module.exports = function(x, settings) {
    var new_result_handler_and_tester, report, run, stats;
    if (settings == null) {
      settings = null;
    }

    /* Timeout for asynchronous operations: */
    if (settings == null) {
      settings = {};
    }
    if (settings['timeout'] == null) {
      settings['timeout'] = 1000;
    }
    stats = {
      'test-count': 0,
      'check-count': 0,
      'meta-count': 0,
      'pass-count': 0,
      'fail-count': 0,
      'failures': {}
    };
    new_result_handler_and_tester = function(test_name) {
      var RH, T, keeper_id;
      RH = {
        'name': test_name
      };
      T = {
        'name': test_name
      };
      keeper_id = null;
      RH.call_with_timeout = function() {
        var P, handler, keeper, method, timeout, _i;
        timeout = arguments[0], method = arguments[1], P = 4 <= arguments.length ? __slice.call(arguments, 2, _i = arguments.length - 1) : (_i = 2, []), handler = arguments[_i++];
        keeper = (function(_this) {
          return function() {
            keeper_id = null;
            warn("(test: " + (rpr(test_name)) + ") timeout reached; proceeding with error");
            return handler(new Error("sorry, timeout reached (" + (rpr(timeout)) + "ms) (" + (rpr(test_name)) + ")"));
          };
        })(this);
        keeper_id = setTimeout(keeper, timeout);
        return method.apply(null, __slice.call(P).concat([(function(_this) {
          return function() {
            var P1;
            P1 = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            if (keeper_id != null) {
              _this.clear_timeout();
              return handler.apply(null, P1);
            }
            return whisper("(test: " + (rpr(test_name)) + ") timeout already reached; ignoring");
          };
        })(this)]));
      };
      RH.clear_timeout = function() {
        if (keeper_id != null) {
          clearTimeout(keeper_id);
          keeper_id = null;
          return true;
        }
        return false;
      };
      RH.on_completion = function(handler) {
        this.clear_timeout();
        whisper("completed: " + (rpr(test_name)));
        return handler();
      };
      RH.on_success = function() {
        stats['pass-count'] += 1;
        return null;
      };
      RH.on_error = function(delta, checked, error) {
        var entry, failures;
        stats['fail-count'] += +1;
        if (error == null) {
          delta += +1;
        }
        entry = CND.get_caller_info(delta, error, true);
        entry['checked'] = checked;
        entry['message'] = error['message'];
        failures = stats['failures'];
        (failures[test_name] != null ? failures[test_name] : failures[test_name] = []).push(entry);
        return null;
      };
      T.eq = function() {
        var P, p;
        P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];

        /* Tests whether all arguments are pairwise and deeply equal. Uses CoffeeNode Bits'n'Pieces' `equal`
        for testing as (1) Node's `assert` distinguishes—unnecessarily—between shallow and deep equality, and,
        worse, [`assert.equal` and `assert.deepEqual` are broken](https://github.com/joyent/node/issues/7161),
        as they use JavaScript's broken `==` equality operator instead of `===`.
         */
        stats['check-count'] += 1;
        if (CND.equals.apply(CND, P)) {
          return RH.on_success();
        } else {
          return RH.on_error(1, true, new Error("not equal: " + (((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = P.length; _i < _len; _i++) {
              p = P[_i];
              _results.push(rpr(p));
            }
            return _results;
          })()).join(', '))));
        }
      };
      T.ok = function(result) {

        /* Tests whether `result` is strictly `true` (not only true-ish). */
        stats['check-count'] += 1;
        if (result === true) {
          return RH.on_success();
        } else {
          return RH.on_error(1, true, new Error("not OK: " + (rpr(result))));
        }
      };
      T.rsvp_ok = function(callback) {
        return (function(_this) {
          return function() {
            var P, error;
            error = arguments[0], P = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
            if (error != null) {
              throw error;
            }
            return callback.apply(null, P);
          };
        })(this);
      };
      T.rsvp_error = function(test, callback) {
        return (function(_this) {
          return function() {
            var P, error;
            error = arguments[0], P = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
            _this.test_error(test, error);
            return callback.apply(null, P);
          };
        })(this);
      };
      T.fail = function(message) {

        /* Fail with message; do not terminate test execution. */
        stats['check-count'] += 1;
        return RH.on_error(1, true, new Error(message));
      };
      T.test_error = function(test, error) {
        var type;
        switch (type = CND.type_of(test)) {
          case 'text':
            return this.eq(error != null ? error['message'] : void 0, test);
          case 'jsregex':
            return this.ok(test.test(error != null ? error['message'] : void 0));
          case 'function':
            return this.ok(test(error));
        }
        throw new Error("expected a text, a RegExp or a function, got a " + type);
      };
      T.throws = function(test, method) {
        var error;
        stats['check-count'] += 1;
        try {
          method();
        } catch (_error) {
          error = _error;
          return this.test_error(test, error);
        }
        throw new Error("expected test to fail with exception, but none was thrown");
      };
      T.check = function(method, callback) {
        var R, error, _ref;
        if (callback == null) {
          callback = null;
        }

        /* TAINT use `callback`? other handler? */
        try {
          method(this);
        } catch (_error) {
          error = _error;
          RH.on_error(0, false, error);
        }
        R = (_ref = stats['failures'][test_name]) != null ? _ref : [];
        delete stats['failures'][test_name];
        stats['fail-count'] += -R.length;
        stats['meta-count'] += +R.length;
        if (callback != null) {
          return callback(R);
        } else {
          return R;
        }
      };
      return [RH, T];
    };
    run = function() {
      var RH, T, tasks, test, test_name, _fn, _ref;
      tasks = [];
      _fn = (function(_this) {
        return function(test_name, test, RH, T) {
          var arity;
          switch (arity = test.length) {
            case 1:
              return tasks.push(function(handler) {
                var error;
                try {
                  test(T);
                } catch (_error) {
                  error = _error;
                  RH.on_error(0, false, error);
                }
                whisper("completed: " + (rpr(test_name)));
                return handler();
              });
            case 2:
              return tasks.push(function(handler) {
                var domain;
                domain = njs_domain.create();
                domain.on('error', function(error) {
                  RH.on_error(0, false, error);
                  return RH.on_completion(handler);
                });
                return domain.run(function() {
                  var done, error;
                  done = function(error) {
                    if (error != null) {
                      RH.on_error(0, false, error);
                    }
                    return RH.on_completion(handler);
                  };
                  try {
                    return RH.call_with_timeout(settings['timeout'], test, T, done);
                  } catch (_error) {
                    error = _error;
                    RH.on_error(0, false, error);
                    return RH.on_completion(handler);
                  }
                });
              });
            default:
              throw new Error("expected test with 1 or 2 arguments, got one with " + arity);
          }
        };
      })(this);
      for (test_name in x) {
        test = x[test_name];
        if (test_name[0] === '_') {
          continue;
        }
        stats['test-count'] += 1;
        test = test.bind(x);
        _ref = new_result_handler_and_tester(test_name), RH = _ref[0], T = _ref[1];
        _fn(test_name, test, RH, T);
      }
      return ASYNC.series(tasks, (function(_this) {
        return function(error) {
          if (error != null) {
            throw error;
          }
          return report();
        };
      })(this));
    };
    report = function() {
      var entries, entry, fail_count, pass_count, test_name, _i, _len, _ref;
      help("                             --=#=--");
      help("                         GUY TEST REPORT");
      help("                             --=#=--");
      _ref = stats['failures'];
      for (test_name in _ref) {
        entries = _ref[test_name];
        help("test case: " + (rpr(test_name)));
        for (_i = 0, _len = entries.length; _i < _len; _i++) {
          entry = entries[_i];
          warn(entry['message']);
          warn('  checked:', entry['checked']);
          warn('  ' + entry['route'] + '#' + entry['line-nr']);
          warn('  ' + entry['source']);
        }
      }
      pass_count = stats['pass-count'];
      fail_count = stats['fail-count'];
      info();
      info('tests:   ', stats['test-count']);
      info('checks:  ', stats['check-count']);
      info('metas:   ', stats['meta-count']);
      (fail_count > 0 ? whisper : help)('passes:  ', stats['pass-count']);
      return (fail_count > 0 ? warn : whisper)('fails:   ', fail_count);
    };
    return run();
  };

}).call(this);
