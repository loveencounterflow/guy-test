// Generated by CoffeeScript 1.8.0
(function() {
  var ASYNC, BNP, ME, TRM, alert, badge, debug, echo, help, info, log, njs_domain, rpr, run, urge, warn, whisper,
    __slice = [].slice;

  njs_domain = require('domain');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'TEST';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  echo = TRM.echo.bind(TRM);

  BNP = require('coffeenode-bitsnpieces');

  ASYNC = require('async');

  ME = this;

  this.get_caller_description = function(delta) {
    var locator;
    if (delta == null) {
      delta = 1;
    }
    locator = (BNP.get_caller_locators(delta + 1))[0];
    return BNP.caller_description_from_locator(locator);
  };

  module.exports = run = function(x) {
    var check_count, error_handler, fail_count, failures, new_tester, pass_count, report, supply_caller_to_error, test_count;
    test_count = 0;
    check_count = 0;
    pass_count = 0;
    fail_count = 0;
    failures = {};
    error_handler = (function(_this) {
      return function(test_name, error) {
        var entry, target;
        debug('©oSiUR', '====');
        fail_count += 1;
        debug('©oSiUR', '1');
        entry = error['caller'];
        debug('©oSiUR', '2');
        entry['message'] = error['message'];
        debug('©oSiUR', '3');
        target = failures[test_name] != null ? failures[test_name] : failures[test_name] = [];
        debug('©oSiUR', '4');
        return target.push(entry);
      };
    })(this);
    supply_caller_to_error = (function(_this) {
      return function(delta, checked, error) {
        var caller;
        if (error == null) {
          delta += +1;
        }
        caller = BNP.get_caller_info(delta, error, true);
        debug('©TCbe7', '%%%%');
        debug('©bRf8c', '!!!!');
        caller['checked'] = checked;
        error['caller'] = caller;
        return error;
      };
    })(this);
    new_tester = function(test_name) {
      var R;
      R = {};
      R.eq = function() {
        var P;
        P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];

        /* Tests whether all arguments are pairwise and deeply equal. Uses CoffeeNode Bits'n'Pieces' `equal`
        for testing as (1) Node's `assert` distinguishes—unnecessarily—between shallow and deep equality, and,
        worse, [`assert.equal` and `assert.deepEqual` are broken](https://github.com/joyent/node/issues/7161),
        as they use JavaScript's broken `==` equality operator instead of `===`.
         */
        check_count += 1;
        if (BNP.equals.apply(BNP, P)) {
          return pass_count += 1;
        } else {
          return error_handler(test_name, supply_caller_to_error(1, true, new Error("not equal: " + (rpr(P)))));
        }
      };
      R.ok = function(result) {

        /* Tests whether `result` is strictly `true` (not only true-ish). */
        check_count += 1;
        if (result === true) {
          return pass_count += 1;
        } else {
          return error_handler(test_name, supply_caller_to_error(1, true, new Error("not OK: " + (rpr(result)))));
        }
      };
      R.rsvp = function(callback) {
        return (function(_this) {
          return function() {
            var P, error;
            error = arguments[0], P = 2 <= arguments.length ? __slice.call(arguments, 1) : [];

            /* TAINT need better error handling */
            if (error != null) {
              throw error;
            }
            return callback.apply(null, P);
          };
        })(this);
      };
      R.fail = function(message) {
        throw new Error(message);
      };
      return R;
    };
    run = function(settings) {
      var T, tasks, test, test_name, _fn;
      if (settings == null) {
        settings = null;
      }
      if (settings == null) {
        settings = {};
      }

      /* Timeout for asynchronous operations: */
      if (settings['timeout'] == null) {
        settings['timeout'] = 1000;
      }
      tasks = [];
      _fn = (function(_this) {
        return function(test_name, test, T) {
          var arity;
          switch (arity = test.length) {
            case 1:
              return tasks.push(function(handler) {
                var error;
                try {
                  test(T);
                } catch (_error) {
                  error = _error;

                  /* TAINT code duplication */
                  if (error['caller'] == null) {
                    supply_caller_to_error(0, false, error);
                  }
                  error_handler(test_name, error);
                }
                return handler();
              });
            case 2:
              return tasks.push(function(handler) {
                var domain;
                domain = njs_domain.create();
                domain.on('error', function(error) {
                  debug('©w2yhy', 'BBBB');

                  /* TAINT code duplication */
                  if (error['caller'] == null) {
                    supply_caller_to_error(0, false, error);
                  }
                  error_handler(test_name, error);
                  handler();
                  return null;
                });
                return domain.run(function() {
                  var error;
                  try {
                    return test(T, (function(_this) {
                      return function() {
                        debug('©ILYFS', '### handler finished ok. ###');
                        return handler();
                      };
                    })(this));
                  } catch (_error) {
                    error = _error;
                    debug('©4wx9Q', 'AAAA');

                    /* TAINT code duplication */
                    supply_caller_to_error(0, false, error);
                    error_handler(test_name, error);
                    return handler();
                  }
                });
              });
            default:
              throw new Error("expected test with 1 or 2 arguments, got one with " + arity);
          }
        };
      })(this);
      for (test_name in x) {
        test = x[test_name];
        test = test.bind(x);
        test_count += 1;
        T = new_tester(test_name);
        _fn(test_name, test, T);
      }
      return ASYNC.series(tasks, (function(_this) {
        return function(error) {
          if (error != null) {
            throw error;
          }
          return report();
        };
      })(this));
    };
    report = function() {
      var entries, entry, test_name, _results;
      info('test_count:   ', test_count);
      info('check_count:  ', check_count);
      info('pass_count:   ', pass_count);
      info('fail_count:   ', fail_count);
      _results = [];
      for (test_name in failures) {
        entries = failures[test_name];
        help("test case: " + (rpr(test_name)));
        _results.push((function() {
          var _i, _len, _results1;
          _results1 = [];
          for (_i = 0, _len = entries.length; _i < _len; _i++) {
            entry = entries[_i];
            warn(entry['message']);
            warn('  checked:', entry['checked']);
            warn('  ' + entry['route'] + '#' + entry['line-nr']);
            _results1.push(warn('  ' + entry['source']));
          }
          return _results1;
        })());
      }
      return _results;
    };
    return run();
  };

}).call(this);
